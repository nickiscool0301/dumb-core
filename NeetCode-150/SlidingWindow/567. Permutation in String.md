https://leetcode.com/problems/permutation-in-string/description/

# Thought process

- Use a sliding window of length len(s1) over s2: compare character counts of the window and s1.
- Build frequency arrays count_s1 and count_s2 of size 26.
- Track matches: Define match as the number of letters where count_s1[i] == count_s2[i]. If match == 26, the window matches s1 exactly.
- Sliding window updates:
  - For each new character entering (s2[right]) and one leaving (s2[left]):
  - Update its frequency in count_s2.
  - Adjust match:
    - If counts become equal → match += 1.
    - If they were equal but got off by 1 → match -= 1.
- After each shift, if match == 26, return True.If end is reached, return False.

```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        if len(s1) > len(s2): return False
        count_s1 = [0] * 26
        count_s2 = [0] * 26
        for i in range(len(s1)):
            count_s1[ord(s1[i]) - ord('a')] += 1
            count_s2[ord(s2[i]) - ord('a')] += 1
        match = 0
        for i in range(26):
            match += (1 if count_s1[i] == count_s2[i] else 0)

        left = 0
        for right in range(len(s1), len(s2)):
            if match == 26: return True

            idx = ord(s2[right]) - ord('a')
            count_s2[idx] += 1
            if count_s1[idx] == count_s2[idx]:
                match += 1
            elif count_s1[idx] + 1 == count_s2[idx]:
                match -= 1

            idx = ord(s2[left]) - ord('a')
            count_s2[idx] -= 1
            if count_s1[idx] == count_s2[idx]:
                match += 1
            elif count_s1[idx] - 1 == count_s2[idx]:
                match -= 1
            left += 1
        return match == 26
```
